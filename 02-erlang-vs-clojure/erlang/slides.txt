# TODOs

1. function / basic stuff

see ./erlang/functions.erl

2. Erlang can sort all sorts of items

(emacs@stella)49> lists:sort([1, [1,2,4], atomar, -2, {hej}, [1, 2, 2], 6, {heap}, {hea}, a]).
[-2,1,6,a,atomar,{hea},{heap},{hej},[1,2,2],[1,2,4]]

3. type system

4. producer-consumer



5. lazy-eval (Erlang har strict eval)

6. datagram-parsing (fx, tcp pakker)


183da2599ab4e0469a4e78f8080045000049716700006c11963bdd805f1a0a000067b6366296003555e16d5202bded2cda9e7a0912b1338fb701f6eb1e3df55559a0e45dd05065535348368848249417a7c15431958c25

183da2599ab4e0469a4e78f8080045000049716700006c11963bdd805f1a0a000067b6366296003555e16d5202bded2cda9e7a0912b1338fb701f6eb1e3df55559a0e45dd05065535348368848249417a7c15431958c25

-define(IP_VERSION, 4).
-define(IP_MIN_HDR_LEN, 5).

DgramSize = byte_size(Dgram),
case Dgram of 
    <<?IP_VERSION:4, HLen:4, SrvcType:8, TotLen:16, 
      ID:16, Flgs:3, FragOff:13,
      TTL:8, Proto:8, HdrChkSum:16,
      SrcIP:32,
      DestIP:32, RestDgram/binary>> when HLen>=5, 4*HLen=<DgramSize ->
        OptsLen = 4*(HLen - ?IP_MIN_HDR_LEN),
        <<Opts:OptsLen/binary,Data/binary>> = RestDgram,
    ...
end.

    <<4:4, HLen:4, SrvcType:8, TotLen:16,  ID:16, Flgs:3, FragOff:13, TTL:8, Proto:8, HdrChkSum:16, SrcIP:32, DestIP:32, RestDgram/binary>>

<<4:4, HLen:4, SrvcType:8, TotLen:16,  ID:16, Flgs:3, FragOff:13, TTL:8, Proto:8, HdrChkSum:16, SrcIP:32, DestIP:32, RestDgram/binary>> = list_to_binary(convert_hex_string:hexstr_to_bin("4500001f000040004011f3cc0a000067dd805f1a6296b636000ba981")).

7. Pattern matching

8. datastrukturer - trae/graf/... 

Erlang: 
atoms, 
simple types,
tupler (records),
lister
queue - O(1) insertion and amortized O(1) 
dict - hashtable get: O(1), insert O(N).
ets
dets
mnesia
gb_trees - balanced tree with ordered keys
process dictionary

9. tco - tail recursion
 - default behaviour - beware of doing it right - try/catch

10. macros in erlang

11. list comprehensions

12. infite lists

13. many_processes

17> 
17> timer:tc(fun many_processes:max/1, [100]).    
Maximum allowed processes: 10000000
Process spawn time = 0.0 (0.0) microseconds
{558,ok}
18> timer:tc(fun many_processes:max/1, [1000]).
Maximum allowed processes: 10000000
Process spawn time = 0.0 (4.0) microseconds
{5062,ok}
19> timer:tc(fun many_processes:max/1, [10000]).
Maximum allowed processes: 10000000
Process spawn time = 4.0 (5.1) microseconds
{50741,ok}
20> timer:tc(fun many_processes:max/1, [100000]).
Maximum allowed processes: 10000000
Process spawn time = 7.7 (6.7) microseconds
{663350,ok}
21> timer:tc(fun many_processes:max/1, [1000000]).
Maximum allowed processes: 10000000
Process spawn time = 7.62 (7.031) microseconds
{6960810,ok}
